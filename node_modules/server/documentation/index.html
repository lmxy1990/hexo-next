<!DOCTYPE html><html class="initial"><head><title>Server.js</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="keywords" content="server, javascript, js, node.js, library, html, html5, express"><meta name="description" content="Flexible server for Node.js"><meta property="og:url" content="http://serverjs.io/"><meta property="og:title" content="Server.js"><meta property="og:description" content="Flexible server for Node.js"><link href="https://unpkg.com/paperdocs@0/paperdocs.min.css" rel="stylesheet"><link href="https://opensource.keycdn.com/fontawesome/4.7.0/font-awesome.min.css" rel="stylesheet"><style>.from-h3 .button::before {
  content: "- ";
}
</style></head><body class="homepage"><nav class="super"><a class="brand" href="/"><img class="logo" src="/public/server.svg"><span class="text">Server</span></a><input class="show" id="bmenu" type="checkbox"><label class="burger pseudo button switch" for="bmenu"></label><header><strong>Server.js</strong></header><div class="menu" data-headers="h1, h2, h3"><ul class="flex one"></ul></div><footer><div class="flex three"><a class="pseudo button" href="/about"><i class="fa fa-info"></i>About</a> <a class="pseudo button" href="https://github.com/serverjs/server" target="_blank"><i class="fa fa-github-alt"></i>Github</a> <a class="button" href="/documentation"><i class="fa fa-file-code-o"></i>Documentation</a></div></footer></nav></body><aside data-headers="h1, h2, h3"><ul></ul></aside><article><h1 id="documentation">Documentation</h1>
<p>This is the documentation for <code>server</code>.</p>
<p>To include the server, <code>require</code> it as a normal Node package:</p>
<pre><code class="lang-js">let server = require(&#39;server&#39;);
</code></pre>
<h2 id="main-function">Main function</h2>
<p><code>server</code> is a function with this signature:</p>
<pre><code class="lang-js">server(options, middleware1, middleware2, ...);
</code></pre>
<p>However, it also has a couple of handy properties:</p>
<ul>
<li><code>server.router</code>: This is <strong>not</strong> the default router from express. Read the section <a href="#router">Router</a> to see how it works.</li>
<li><code>server.express</code>: The original express server. As express is a dependency, this is the result of doing <code>require(&#39;express&#39;)</code>.</li>
</ul>
<h2 id="options">Options</h2>
<p>The first argument of the main function is for setting the options. It can be nothing, a single integer or a plain object:</p>
<pre><code class="lang-js">server();
server(3000);
server({ port: 3000 });  // the same
</code></pre>
<p>As you can guess, internally if it is a single integer it will be converted to the object <code>{ port: ARG }</code>. This is a handy shortcut in case you want the default options except for the port, otherwise you can specify the options (defaults shown here):</p>
<pre><code class="lang-js">server({
  port: process.env.PORT || 3000,
  public: &#39;./public&#39;,
  viewengine: &#39;pug&#39;,

  middle: {
    // Default middleware options here, see below
  }
});
</code></pre>
<h3 id="-port-"><code>port</code></h3>
<p>This is slightly different from other options, as the variable within the environment will always overwrite this option. This is so Heroku and other servers will work nicely. So this is the inclusion order, from more important to less:</p>
<ul>
<li><code>.env</code>: the variable within the environment.</li>
<li><code>server(3000)</code> || <code>server({ port: 3000 })</code>: the variable set manually when launching the server.</li>
<li><code>3000</code>: the default port if nothing else was specified.</li>
</ul>
<p>To set the port in the environment, create a file called <code>.env</code> with this:</p>
<pre><code>PORT=3000
</code></pre><p>This will allow for your server to work nicely with some hosts such as Heroku, since those provide the port as an environment variable. Don&#39;t forget then to add <code>.env</code> then to your <code>.gitignore</code>.</p>
<h3 id="-public-"><code>public</code></h3>
<p>The folder where your static assets are. This includes images, styles, javascript for the browser, etc. Any file that you want directly accessible through <code>example.com/myfile.pdf</code> should be in this folder.</p>
<h2 id="middleware">Middleware</h2>
<p>One of the most powerful things from express and thus from <code>server</code> is the Middleware. We extended it by setting some default, useful middleware, but we wanted to also give you the flexibility to edit this.</p>
<blockquote>
<p>We recommend adding your own middleware to the folder <code>/middle</code>, and all examples below will make this assumption.</p>
</blockquote>
<p>There are four ways of loading middleware with <code>server</code> which are explained below. The most important difference is named (object) vs unnamed (others) middleware, as only named middleware will overwrite the defaults.</p>
<!-- ### String

This is the simplest way to add middleware, it will just require() that string. This is not so useful with some packages since they require an additional function call (such as `require('body-parser')()`), however it's perfect for your own middleware:

```js
// Load the middleware 'body-parser' from the folder '/middle'
server(3000, './middle/body-parser.js');
```

Then inside that `./middle/body-parser.js`:

```js
module.exports = function(req, res, next) {

  // do your thing here

  next();
}
``` -->
<h3 id="function">Function</h3>
<p>Middleware <em>is</em> a function that accepts <code>(req, res, next)</code> (or <code>(err, req, res, next)</code> parameters, so all other methods are ultimately converted to this one. Read more just by googling&#39; &quot;express middleware&quot; or &quot;write middleware express&quot;.</p>
<p>As a simple example, there are many pre-packaged modules, so let&#39;s see one example where we imagine that <code>body-parser</code> is not loaded by default:</p>
<pre><code class="lang-js">// Include bodyparser in your file
let bodyparser = require(&#39;body-parser&#39;)({ extended: true });

// Load it as middleware
server(3000, bodyparser);
</code></pre>
<h3 id="array">Array</h3>
<p>This will be converted to a series of functions, and inside the array there can be any of the other types. It is useful to bundle them by category:</p>
<pre><code class="lang-js">let parsers = [
  // ...
];

let { get, post } = server.router;
let routes = [
  get(&#39;/&#39;, (req, res) =&gt; { /* ... */ }),
  post(&#39;/&#39;, (req, res) =&gt; { /* ... */ })
];

server(3000, parsers, routes);
</code></pre>
<h3 id="object">Object</h3>
<p>You can name them, and they will <strong>replace one of the default middlewares if the name matches it</strong>. Let&#39;s go with the simple example of <code>body-parser</code>:</p>
<pre><code class="lang-js">let server = require(&#39;server&#39;);

// Uses body-parser
server(3000);

// Don&#39;t use body-parser
server(3000, { bodyparser: false });

// Use a different body-parser
server(3000, { bodyparser: coolerBodyParser() });
</code></pre>
<p>This <em>might</em> break some code since it removes the original one and sets it in the current position. Let&#39;s see what this means with an example:</p>
<pre><code class="lang-js">// Imagine the default middlewares are a, b and c
server(3000, d, { b: newMiddleWare() }, e);
</code></pre>
<p>In most situations this won&#39;t change anything, but in some edge cases it <em>might</em> bring nasty bugs so a solution or alternative has to be found before 1.0.0.</p>
<h2 id="router">Router</h2>
<p>In the end of the day, routes are just a specific kind of middleware. There are many ways of including them, however we recommend these two:</p>
<h3 id="simple-router">Simple router</h3>
<p>To define a simple router, you could do:</p>
<pre><code class="lang-js">let server = require(&#39;server&#39;);

// Import methods &#39;get&#39; and &#39;post&#39; from the router
let { get, post } = server.router;

server(3000,
  get(&#39;/users&#39;, (req, res) =&gt; { /* ... */ }),
  post(&#39;/users&#39;, (req, res) =&gt; { /* ... */ })
);
</code></pre>
<h3 id="complex-router">Complex router</h3>
<p>If you are going to have many routes, we recommend splitting it into a separated file, either in the root of the project as <code>routes.js</code> or in a different place:</p>
<pre><code class="lang-js">// app.js
let server = require(&#39;server&#39;);
let routes = require(&#39;./routes&#39;);

server(3000, routes);
</code></pre>
<pre><code class="lang-js">// routes.js
let { get, post } = require(&#39;server&#39;).router;
let ctrl = require(&#39;auto-load&#39;)(&#39;controllers&#39;);

// You can simply export an array of routes
module.exports = [
  get(&#39;/&#39;, ctrl.home.index),
  get(&#39;/users&#39;, ctrl.users.index),
  post(&#39;/users&#39;, ctrl.users.add),
  get(&#39;/photos&#39;, ctrl.photos.index),
  post(&#39;/photos&#39;, ctrl.photos.add),
  ...
];
</code></pre>
<p>Note: the previous is the same as this, but we use the package <code>auto-load</code> for simplicity:</p>
<pre><code class="lang-js">let { get, post } = require(&#39;server&#39;).router;
let home = require(&#39;./controllers/home&#39;);
let users = require(&#39;./controllers/users&#39;);
let photos = require(&#39;./controllers/photos&#39;);

module.exports = [
  get(&#39;/&#39;, home.index),
  get(&#39;/users&#39;, users.index),
  post(&#39;/users&#39;, users.add),
  get(&#39;/photos&#39;, photos.index),
  post(&#39;/photos&#39;, photos.add),
  ...
];
</code></pre>
<h2 id="in-depth">In-depth</h2>
<p>Some extra info if you want to get into some more advanced configuration.</p>
<h3 id="promise">Promise</h3>
<p>The main function returns a promise which will be fulfilled when the server is launched or might throw an initialization error such as port is already in use. In practical terms, you can consider the parameter of the promise to be the original http-server extended with <code>options</code> with the original options, however internally it&#39;s a proxy:</p>
<pre><code class="lang-js">server().then(instance =&gt; {

  // Run the server for a single second then close it
  setTimeout(() =&gt; {
    instance.close();
  }, 1000);
}).catch(error =&gt; {
  console.log(&quot;There was an error:&quot;, error);
});
</code></pre>
<p>For most purposes you can just ignore it and launch the server ignoring the return value:</p>
<pre><code class="lang-js">server();
</code></pre>
<p>This might be useful for error-handling, debugging and testing (see the tests in <code>__tests__</code>).</p>
</article><script src="https://unpkg.com/paperdocs@0/paperdocs.min.js"></script><script src="//localhost:35729/livereload.js"></script></html>